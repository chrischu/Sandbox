<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Development\SolutionInspector\src\SolutionInspector.DefaultRules\ProjectXPathRule.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.Serialization;
using System.Xml.Linq;
using System.Xml.XPath;
using JetBrains.Annotations;
using SolutionInspector.Api.ObjectModel;
using SolutionInspector.Api.Rules;
using SolutionInspector.Commons.Extensions;
using SolutionInspector.Configuration.Attributes;

namespace SolutionInspector.DefaultRules
{
  /// &lt;summary&gt;
  ///   Evaluates an XPath expression (configured via &lt;see cref=&quot;XPath&quot; /&gt;) against the project XML file
  ///   and returns a violation if it does not evaluate to &lt;c&gt;true&lt;/c&gt;.
  /// &lt;/summary&gt;
  /// &lt;remarks&gt;
  ///   Please note that in order to make writing XPath expressions easier all namespaces are ignored. To change this configure the rule like this:
  ///   &lt;code&gt;&amp;lt;rule type=&quot;...&quot; xPath=&quot;...&quot; ignoreNamespaces=&quot;false&quot; /&amp;gt;&lt;/code&gt;
  /// &lt;/remarks&gt;
  [Description (
    &quot;Evaluates an XPath expression (configured via &#39;xPath&#39;) against the project XML file and returns a violation if it does not &quot; +
    &quot;evaluate to true. By default all XML namespaces are ignored, if that is not desirable, change the &#39;ignoreNamespaces&#39; property to false&quot;)]
  public class ProjectXPathRule : ProjectRule
  {
    /// &lt;summary&gt;
    ///   XPath expression that should evaluate to true.
    /// &lt;/summary&gt;
    [ConfigurationValue]
    [Description (&quot;XPath expression that should evaluate to true.&quot;)]
    public string XPath
    {
      get =&gt; GetConfigurationValue&lt;string&gt;();
      set =&gt; SetConfigurationValue(value);
    }

    /// &lt;summary&gt;
    ///   Controls if XML namespaces should be ignored during XPath evaluation.
    /// &lt;/summary&gt;
    [ConfigurationValue(IsOptional = true, DefaultValue = &quot;true&quot;)]
    [Description (&quot;Controls whether XML namespaces should be ignored or not during XPath evaluation.&quot;)]
    public bool IgnoreNamespaces
    {
      get =&gt; GetConfigurationValue&lt;bool&gt;();
      set =&gt; SetConfigurationValue(value);
    }

    /// &lt;inheritdoc /&gt;
    public override IEnumerable&lt;IRuleViolation&gt; Evaluate ([NotNull] IProject target)
    {
      var xdoc = GetXDocumentForXPathEvaluation(target.ProjectXml, IgnoreNamespaces);
      var result = xdoc.XPathEvaluate(XPath);

      if (result.GetType() != typeof(bool))
        throw new InvalidXPathExpressionException(XPath);

      var boolResult = (bool) result;

      if (!boolResult)
        yield return new RuleViolation(this, target, $&quot;The XPath expression &#39;{XPath}&#39; did not evaluate to &#39;true&#39;, but to &#39;false&#39;.&quot;);
    }

    private XDocument GetXDocumentForXPathEvaluation (XDocument xdoc, bool ignoreNamespaces)
    {
      return ignoreNamespaces ? StripNamespaces(xdoc) : xdoc;
    }

    [ExcludeFromCodeCoverage]
    private XDocument StripNamespaces (XDocument xdoc)
    {
      var copy = new XDocument(xdoc);

      foreach (var element in copy.Root.AssertNotNull().DescendantsAndSelf())
      {
        if (element.Name.Namespace != XNamespace.None)
          element.Name = XNamespace.None.GetName(element.Name.LocalName);

        if (element.Attributes().Any(a =&gt; a.IsNamespaceDeclaration || a.Name.Namespace != XNamespace.None))
        {
          var newAttributes =
              element.Attributes()
                  .Where(a =&gt; !a.IsNamespaceDeclaration)
                  .Select(a =&gt; new XAttribute(XNamespace.None.GetName(a.Name.LocalName), a.Value));

          element.ReplaceAttributes(newAttributes);
        }
      }

      return copy;
    }

    /// &lt;summary&gt;
    ///   Occurs when the XPath expression used in &lt;see cref=&quot;XPath&quot; /&gt; does not evaluate to a boolean value.
    /// &lt;/summary&gt;
    [Serializable]
    public class InvalidXPathExpressionException : Exception
    {
      /// &lt;summary&gt;
      ///   Creates a new &lt;see cref=&quot;InvalidXPathExpressionException&quot; /&gt;
      /// &lt;/summary&gt;
      public InvalidXPathExpressionException (string xPathExpression, Exception innerException = null)
        : base($&quot;The configured XPath expression &#39;{xPathExpression}&#39; does not evaluate to a boolean value.&quot;, innerException)
      {
      }

      /// &lt;summary&gt;
      ///   Serialization constructor.
      /// &lt;/summary&gt;
      [ExcludeFromCodeCoverage /* Serialization ctor */]
      protected InvalidXPathExpressionException (SerializationInfo info, StreamingContext context)
        : base(info, context)
      {
      }
    }
  }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[37,14,37,45,1],[38,14,38,42,1],[48,14,48,43,1],[49,14,49,42,1],[55,7,55,86,1],[56,7,56,46,1],[58,7,58,44,1],[59,9,59,58,1],[61,7,61,38,1],[63,7,63,23,1],[64,9,64,133,1],[65,5,65,6,1],[69,7,69,62,1],[106,11,106,125,1]]);
    </script>
  </body>
</html>