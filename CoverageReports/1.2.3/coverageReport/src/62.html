<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Development\SolutionInspector\src\SolutionInspector.Internals\NameFilterGenerator.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using SolutionInspector.Api;
using SolutionInspector.Api.Configuration;
using SolutionInspector.Commons.Extensions;
using SolutionInspector.Commons.Utilities;

namespace SolutionInspector.Internals
{
  /// &lt;summary&gt;
  ///   Utility class to generate a &lt;see cref=&quot;INameFilter&quot; /&gt; from a set of available names and a set of selected names.
  /// &lt;/summary&gt;
  public static class NameFilterGenerator
  {
    /// &lt;summary&gt;
    ///   Generates a &lt;see cref=&quot;INameFilter&quot; /&gt; from the given set of &lt;paramref name=&quot;names&quot; /&gt;.
    /// &lt;/summary&gt;
    public static INameFilter Generate (IReadOnlyCollection&lt;Tuple&lt;string, bool&gt;&gt; names)
    {
      Trace.Assert(names.Select(x =&gt; x.Item1).Distinct().Count() == names.Count, &quot;Names can only be passed once.&quot;);

      var filtered = names.Where(n =&gt; !string.IsNullOrWhiteSpace(n.Item1)).ToList();
      var availableNames = filtered.Select(n =&gt; n.Item1).ToList();
      var selectedNames = filtered.Where(n =&gt; n.Item2).Select(n =&gt; n.Item1).ToList();
      var unselectedNames = filtered.Where(n =&gt; !n.Item2).Select(n =&gt; n.Item1).ToList();

      if (availableNames.Count == selectedNames.Count)
        return new NameFilter(new[] { &quot;*&quot; });

      if (selectedNames.Count == 0)
        return new NameFilter(new string[0], new[] { &quot;*&quot; });

      var possibleNameFilters = GetPossibleNameFilters(selectedNames).ToArray();
      var nameFilters = possibleNameFilters.SelectMany(
        nameFilter =&gt;
        {
          var excludes = unselectedNames.Where(nameFilter.IsMatch).ToList();

          if (excludes.Count == 0)
            return new[] { nameFilter };

          var possibleExcludeFilters = GetPossibleNameFilters(excludes);
          var filteredPossibleExcludeFilters = possibleExcludeFilters.Where(f =&gt; selectedNames.All(x =&gt; !f.IsMatch(x)));

          return filteredPossibleExcludeFilters.Select(f =&gt; new NameFilter(nameFilter.Includes, f.Includes));
        }).ToList();
      return nameFilters
          .OrderBy(f =&gt; f.Includes.Count + f.Excludes.Count)
          .ThenBy(f =&gt; f.Includes.Count(s =&gt; s.Contains(&quot;*&quot;)) + f.Excludes.Count(s =&gt; s.Contains(&quot;*&quot;)))
          .First();
    }

    private static IEnumerable&lt;NameFilter&gt; GetPossibleNameFilters(IReadOnlyCollection&lt;string&gt; elements)
    {
      yield return new NameFilter(elements);
      yield return new NameFilter(new[] { &quot;*&quot; });

      var possibleGroupings = GetPossibleGroupings(elements);

      foreach (var possibleGrouping in possibleGroupings)
        foreach (var nameFilter in GetOptimalNameFiltersForGrouping(possibleGrouping))
          yield return nameFilter;
    }

    private static IEnumerable&lt;IEnumerable&lt;IEnumerable&lt;string&gt;&gt;&gt; GetPossibleGroupings(IReadOnlyCollection&lt;string&gt; elements)
    {
      var maxLength = elements.Max(s =&gt; s.Length);

      var possibleGroupings =
          new HashSet&lt;IEnumerable&lt;IEnumerable&lt;string&gt;&gt;&gt;(new CollectionEqualityComparer&lt;IEnumerable&lt;string&gt;&gt;(new CollectionEqualityComparer&lt;string&gt;()));

      for (var prefixLength = 0; prefixLength &lt;= maxLength; prefixLength++)
        for (var suffixLength = 0; suffixLength + prefixLength &lt;= maxLength; suffixLength++)
        {
          var group = elements.GroupBy(e =&gt; e.Prefix(prefixLength) + e.Suffix(suffixLength)).Select(x =&gt; x.ToList()).ToList();
          if (group.Count != elements.Count)
            possibleGroupings.Add(group);
        }

      return possibleGroupings;
    }

    private static IEnumerable&lt;NameFilter&gt; GetOptimalNameFiltersForGrouping(IEnumerable&lt;IEnumerable&lt;string&gt;&gt; grouping)
    {
      grouping = grouping.Select(e =&gt; OptimizeGroup(e.ToList()).ToList()).ToList();

      var list = new HashSet&lt;NameFilter&gt;();
      BuildPossibleFilters(new string[0], grouping.ToList(), list);

      return list;
    }

    private static void BuildPossibleFilters(
      IReadOnlyCollection&lt;string&gt; includes,
      IReadOnlyCollection&lt;IEnumerable&lt;string&gt;&gt; possibleIncludes,
      ISet&lt;NameFilter&gt; result)
    {
      if (possibleIncludes.Any())
      {
        foreach (var x in possibleIncludes.First())
          BuildPossibleFilters(includes.Concat(new[] { x }).ToList(), possibleIncludes.Skip(1).ToList(), result);
      }
      else
        result.Add(new NameFilter(includes.ToList()));
    }

    private static IEnumerable&lt;string&gt; OptimizeGroup(IReadOnlyCollection&lt;string&gt; elements)
    {
      if (elements.Count == 1)
      {
        yield return elements.Single();
        yield break;
      }

      var longestCommonPrefix = GetLongestCommonAffix(elements, (s, i) =&gt; s.Prefix(i));
      var longestCommonSuffix = GetLongestCommonAffix(elements, (s, i) =&gt; s.Suffix(i));

      var foundCommonPrefix = !string.IsNullOrEmpty(longestCommonPrefix);
      var foundCommonSuffix = !string.IsNullOrEmpty(longestCommonSuffix);

      if (foundCommonPrefix)
        yield return longestCommonPrefix + &quot;*&quot;;

      if (foundCommonSuffix)
        yield return &quot;*&quot; + longestCommonSuffix;

      if (foundCommonPrefix &amp;&amp; foundCommonSuffix)
        yield return longestCommonPrefix + &quot;*&quot; + longestCommonSuffix;
    }

    [ExcludeFromCodeCoverage]
    private static string GetLongestCommonAffix(
      IReadOnlyCollection&lt;string&gt; elements,
      Func&lt;string, int, string&gt; affixFunc)
    {
      var maxLength = elements.Max(s =&gt; s.Length);

      for (var affixLength = 1; affixLength &lt;= maxLength; affixLength++)
      {
        var grouped = elements.GroupBy(e =&gt; affixFunc(e, affixLength)).ToList();
        if (grouped.Count &gt; 1)
          return affixFunc(elements.First(), affixLength - 1);
      }

      throw new InvalidOperationException(&quot;Unreachable code&quot;);
    }
  }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[23,7,23,38,1],[23,38,23,45,1],[23,45,23,116,1],[23,7,23,116,1],[25,7,25,39,1],[25,39,25,74,1],[25,74,25,85,1],[25,7,25,85,1],[26,7,26,49,1],[26,49,26,56,1],[26,56,26,67,1],[26,7,26,67,1],[27,7,27,47,1],[27,47,27,54,1],[27,54,27,68,1],[27,68,27,75,1],[27,75,27,86,1],[27,7,27,86,1],[28,7,28,49,1],[28,49,28,57,1],[28,57,28,71,1],[28,71,28,78,1],[28,78,28,89,1],[28,7,28,89,1],[30,7,30,55,1],[31,9,31,46,1],[33,7,33,36,1],[34,9,34,61,1],[36,7,36,81,1],[37,7,40,11,1],[40,11,40,77,1],[40,77,42,11,1],[42,11,42,35,1],[42,35,43,13,1],[43,13,43,41,1],[43,41,45,11,1],[45,11,45,73,1],[45,73,46,11,1],[46,11,46,82,1],[46,82,46,105,1],[46,105,46,118,1],[46,118,46,119,1],[46,82,46,119,1],[46,119,46,121,1],[46,11,46,121,1],[46,121,48,11,1],[48,11,48,61,1],[48,61,48,108,1],[48,108,48,110,1],[48,11,48,110,1],[48,110,49,21,1],[37,7,49,21,1],[50,7,51,25,1],[51,25,51,60,1],[51,60,52,24,1],[52,24,52,46,1],[52,46,52,61,1],[52,61,52,87,1],[52,87,52,102,1],[52,102,52,103,1],[52,24,52,103,1],[52,103,53,20,1],[50,7,53,20,1],[58,7,58,45,1],[59,7,59,50,1],[61,7,61,62,1],[63,16,63,36,1],[63,37,63,39,1],[63,40,63,57,1],[64,18,64,32,1],[64,33,64,35,1],[64,36,64,86,1],[65,11,65,35,1],[66,5,66,6,1],[70,7,70,41,1],[70,41,70,49,1],[70,49,70,51,1],[70,7,70,51,1],[72,7,73,152,1],[75,12,75,32,1],[75,34,75,59,1],[75,61,75,75,1],[76,14,76,34,1],[76,36,76,76,1],[76,78,76,92,1],[78,11,78,45,1],[78,45,78,92,1],[78,92,78,106,1],[78,106,78,116,1],[78,116,78,127,1],[78,11,78,127,1],[79,11,79,45,1],[80,13,80,42,1],[83,7,83,32,1],[88,7,88,39,1],[88,39,88,73,1],[88,73,88,84,1],[88,7,88,84,1],[90,7,90,44,1],[91,7,91,68,1],[93,7,93,19,1],[101,7,101,34,1],[103,18,103,23,1],[103,24,103,26,1],[103,27,103,51,1],[104,11,104,114,1],[107,9,107,55,1],[112,7,112,31,1],[114,9,114,40,1],[115,9,115,21,1],[118,7,118,75,1],[118,75,118,86,1],[118,86,118,88,1],[118,7,118,88,1],[119,7,119,75,1],[119,75,119,86,1],[119,86,119,88,1],[119,7,119,88,1],[121,7,121,74,1],[122,7,122,74,1],[124,7,124,29,1],[125,9,125,48,1],[127,7,127,29,1],[128,9,128,48,1],[130,7,130,50,1],[131,9,131,70,1],[132,5,132,6,1]]);
    </script>
  </body>
</html>