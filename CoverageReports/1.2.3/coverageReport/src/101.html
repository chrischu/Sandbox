<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Development\SolutionInspector\src\SolutionInspector.BuildTool\Commands\GenerateSchemaCommand.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using JetBrains.Annotations;
using SolutionInspector.Commons.Console;
using SolutionInspector.Commons.Extensions;
using Wrapperator.Interfaces.IO;
using Wrapperator.Interfaces.Reflection;
using Wrapperator.Interfaces.Xml;

namespace SolutionInspector.BuildTool.Commands
{
  internal class GenerateSchemaCommand : ConsoleCommandBase&lt;GenerateSchemaCommand.RawArguments, GenerateSchemaCommand.ParsedArguments&gt;
  {
    private readonly IFileStatic _file;
    private readonly IConsoleHelper _consoleHelper;
    private readonly IXmlWriterStatic _xmlWriter;
    private readonly IAssemblyStatic _assembly;
    private readonly IRuleAssemblySchemaCreator _ruleAssemblySchemaCreator;

    public GenerateSchemaCommand (
        IAssemblyStatic assembly,
        IFileStatic file,
        IConsoleHelper consoleHelper,
        IXmlWriterStatic xmlWriter,
        IRuleAssemblySchemaCreator ruleAssemblySchemaCreator)
        : base(&quot;generateSchema&quot;, &quot;Generates a XSD schema for the rules contained in the specified assembly.&quot;)
    {
      _file = file;
      _consoleHelper = consoleHelper;
      _xmlWriter = xmlWriter;
      _assembly = assembly;
      _ruleAssemblySchemaCreator = ruleAssemblySchemaCreator;
    }

    protected override void SetupArguments (IArgumentsBuilder&lt;RawArguments&gt; argumentsBuilder)
    {
      argumentsBuilder
          .Values(c =&gt; c.Value(&quot;assemblyFilePath&quot;, (a, v) =&gt; a.AssemblyFilePath = v))
          .Option&lt;string&gt;(&quot;baseSchemaVersion&quot;, &quot;v&quot;, &quot;The version of the base schema to reference in the created schema&quot;, (a, v) =&gt; a.BaseSchemaVersion = v)
          .Option&lt;string&gt;(
              &quot;outputFilePath&quot;,
              &quot;o&quot;,
              &quot;A file path defining where the resulting XSD schema should be saved to. Defaults to &#39;&lt;assemblyName&gt;.xsd&#39;.&quot;,
              (a, v) =&gt; a.OutputFilePath = v)
          .Flag(&quot;force&quot;, &quot;f&quot;, &quot;Overwrite output file if it exists without asking for confirmation.&quot;, (a, v) =&gt; a.Force = v);
    }

    protected override ParsedArguments ValidateAndParseArguments (RawArguments arguments)
    {
      var assembly = LoadAssembly(arguments.AssemblyFilePath);

      var baseSchemaVersion = arguments.BaseSchemaVersion ?? BuildToolProgram.DefaultBaseSchemaVersion;
      var baseSchemaNamespace = string.Format(BuildToolProgram.BaseSchemaNamespaceTemplate, baseSchemaVersion);

      var outputFilePath = GetAndValidateOutputFilePath(arguments.OutputFilePath, arguments.AssemblyFilePath);

      return new ParsedArguments(assembly, baseSchemaNamespace, outputFilePath, arguments.Force);
    }

    private IAssembly LoadAssembly (string assemblyPath)
    {
      try
      {
        return _assembly.LoadFrom(assemblyPath);
      }
      catch (FileNotFoundException)
      {
        throw ReportArgumentValidationError($&quot;Assembly &#39;{assemblyPath}&#39; could not be found&quot;);
      }
      catch (Exception ex)
      {
        throw ReportArgumentValidationError($&quot;Unexpected error while loading assembly &#39;{assemblyPath}&#39;&quot;, ex);
      }
    }

    private string GetAndValidateOutputFilePath ([CanBeNull] string outputFilePath, string assemblyFilePath)
    {
      try
      {
        outputFilePath = outputFilePath ?? Path.ChangeExtension(assemblyFilePath, &quot;xsd&quot;).AssertNotNull();

        if (!_file.Exists(outputFilePath))
        {
          var directoryPath = Path.GetDirectoryName(Path.GetFullPath(outputFilePath)).AssertNotNull();
          Directory.CreateDirectory(directoryPath);
          _file.WriteAllText(outputFilePath, &quot;&quot;);
          _file.Delete(outputFilePath);
        }

        return outputFilePath;
      }
      catch (Exception ex)
      {
        throw ReportArgumentValidationError($&quot;Invalid output path &#39;{outputFilePath}&#39;&quot;, ex);
      }
    }

    protected override int Run (ParsedArguments arguments)
    {
      if (_file.Exists(arguments.OutputFilePath) &amp;&amp; !arguments.Force)
      {
        if(!_consoleHelper.Confirm($&quot;File &#39;{arguments.OutputFilePath}&#39; already exists. Do you want to overwrite it?&quot;))
          return ReportAbortion();
      }

      try
      {
        var schema = _ruleAssemblySchemaCreator.CreateSchema(arguments.RuleAssembly, arguments.BaseSchemaNamespace);

        using(var stream = _file.Create(arguments.OutputFilePath))
        using (var xmlWriter = _xmlWriter.Create(stream, new XmlWriterSettings { Encoding = Encoding.UTF8, Indent = true }))
          schema.Write(xmlWriter._XmlWriter);

        return ConsoleConstants.SuccessExitCode;
      }
      catch (XmlSchemaException ex)
      {
        return ReportExecutionError(&quot;The generated schema is not valid&quot;, ex);
      }
      catch (Exception ex)
      {
        return ReportExecutionError(&quot;Unexpected error while generating schema&quot;, ex);
      }
    }

    public class RawArguments
    {
      [NotNull]
      // ReSharper disable once NotNullMemberIsNotInitialized (initialized by argument parsing)
      public string AssemblyFilePath { get; set; }

      [CanBeNull]
      public string BaseSchemaVersion { get; set; }

      [CanBeNull]
      public string OutputFilePath { get; set; }
      public bool Force { get; set; }
    }

    public class ParsedArguments
    {
      public ParsedArguments (IAssembly ruleAssembly, string baseSchemaNamespace, string outputFilePath, bool force)
      {
        RuleAssembly = ruleAssembly;
        BaseSchemaNamespace = baseSchemaNamespace;
        OutputFilePath = outputFilePath;
        Force = force;
      }

      [NotNull]
      public IAssembly RuleAssembly { get; }

      [NotNull]
      public string BaseSchemaNamespace { get; }

      [NotNull]
      public string OutputFilePath { get; }
      public bool Force { get; }
    }
  }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,11,29,110,1],[31,7,31,20,1],[32,7,32,38,1],[33,7,33,30,1],[34,7,34,28,1],[35,7,35,62,1],[40,7,41,24,1],[41,24,41,62,1],[41,62,41,84,1],[41,84,41,85,1],[41,24,41,85,1],[41,85,42,132,1],[42,132,42,155,1],[42,155,47,25,1],[47,25,47,45,1],[47,45,48,112,1],[48,112,48,123,1],[48,123,48,125,1],[40,7,48,125,1],[53,7,53,63,1],[55,7,55,104,1],[56,7,56,112,1],[58,7,58,111,1],[60,7,60,98,1],[67,9,67,49,1],[69,7,69,36,1],[71,9,71,94,1],[73,7,73,27,1],[75,9,75,110,1],[77,5,77,6,1],[83,9,83,106,1],[85,9,85,43,1],[87,11,87,103,1],[88,11,88,52,1],[89,11,89,50,1],[90,11,90,40,1],[93,9,93,31,1],[95,7,95,27,1],[97,9,97,92,1],[99,5,99,6,1],[103,7,103,70,1],[105,9,105,119,1],[106,11,106,35,1],[111,9,111,117,1],[113,15,113,66,1],[114,16,114,124,1],[115,11,115,46,1],[117,9,117,49,1],[119,7,119,36,1],[121,9,121,78,1],[123,7,123,27,1],[125,9,125,85,1],[127,5,127,6,1],[145,7,145,117,1],[147,9,147,37,1],[148,9,148,51,1],[149,9,149,41,1],[150,9,150,23,1]]);
    </script>
  </body>
</html>