<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Development\SolutionInspector\src\SolutionInspector.BuildTool\Commands\ValidateRuleAssemblyCommand.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using JetBrains.Annotations;
using SolutionInspector.Api.Rules;
using SolutionInspector.Commons.Console;
using SolutionInspector.Commons.Extensions;
using SolutionInspector.Configuration.Validation;
using Wrapperator.Interfaces.Reflection;

namespace SolutionInspector.BuildTool.Commands
{
  internal class ValidateRuleAssemblyCommand : ConsoleCommandBase&lt;ValidateRuleAssemblyCommand.RawArguments, ValidateRuleAssemblyCommand.ParsedArguments&gt;
  {
    private readonly IAssemblyStatic _assembly;

    public ValidateRuleAssemblyCommand (IAssemblyStatic assembly)
        : base(&quot;validateRuleAssembly&quot;, &quot;Validates a rule assembly.&quot;)
    {
      _assembly = assembly;
    }

    protected override void SetupArguments (IArgumentsBuilder&lt;RawArguments&gt; argumentsBuilder)
    {
      argumentsBuilder.Values(c =&gt; c.Value(&quot;ruleAssemblyFilePath&quot;, (a, v) =&gt; a.RuleAssemblyPath = v));
    }

    protected override ParsedArguments ValidateAndParseArguments (RawArguments arguments)
    {
      var assembly = LoadAssembly(arguments.RuleAssemblyPath);
      var ruleTypes = assembly.GetTypes().Where(t =&gt; typeof(Rule).IsAssignableFrom(t) &amp;&amp; !t.IsAbstract &amp;&amp; !t.IsInterface)
          .ToList();

      if (ruleTypes.Count == 0)
        throw ReportArgumentValidationError($&quot;Rule assembly &#39;{arguments.RuleAssemblyPath}&#39; does not contain a single rule&quot;);

      return new ParsedArguments(arguments.RuleAssemblyPath, ruleTypes);
    }

    private IAssembly LoadAssembly (string assemblyPath)
    {
      try
      {
        return _assembly.LoadFrom(assemblyPath);
      }
      catch (FileNotFoundException)
      {
        throw ReportArgumentValidationError($&quot;Rule assembly &#39;{assemblyPath}&#39; could not be found&quot;);
      }
      catch (Exception ex)
      {
        throw ReportArgumentValidationError($&quot;Unexpected error while loading rule assembly &#39;{assemblyPath}&#39;&quot;, ex);
      }
    }

    protected override int Run (ParsedArguments arguments)
    {
      var ruleTypesWithValidationErrors = new List&lt;(Type ruleType, IReadOnlyDictionary&lt;string, IReadOnlyCollection&lt;string&gt;&gt; validationErrors)&gt;();

      foreach (var ruleType in arguments.RuleTypes)
      {
        try
        {
          ConfigurationValidator.Validate(ruleType);
        }
        catch (ConfigurationValidationException ex)
        {
          Trace.Assert(ex.DocumentValidationErrors.Count == 0, &quot;There should be no document validation errors here&quot;);
          ruleTypesWithValidationErrors.Add((ruleType, ex.PropertyValidationErrors));
        }
      }

      if (ruleTypesWithValidationErrors.Count == 0)
      {
        LogInfo($&quot;Rule assembly &#39;{arguments.RuleAssemblyPath}&#39; is valid&quot;);
        return ConsoleConstants.SuccessExitCode;
      }

      var formattedValidationErrors = ruleTypesWithValidationErrors.FormatAsList(
          &quot;Rule assembly is not valid. The following rule types had errors&quot;,
          ruleTypeWithValidationErrors =&gt; ruleTypeWithValidationErrors.validationErrors.FormatAsList(
              ruleTypeWithValidationErrors.ruleType.Name,
              propertiesWithValidationErrors =&gt; propertiesWithValidationErrors.Value.FormatAsList($&quot;For property &#39;{propertiesWithValidationErrors.Key}&#39;&quot;)));

      LogError(formattedValidationErrors);
      return ConsoleConstants.ErrorExitCode;
    }

    public class RawArguments
    {
      [NotNull]
      // ReSharper disable once NotNullMemberIsNotInitialized (initialized by argument parsing)
      public string RuleAssemblyPath { get; set; }
    }

    public class ParsedArguments
    {
      public ParsedArguments (string ruleAssemblyPath, IReadOnlyList&lt;Type&gt; ruleTypes)
      {
        RuleAssemblyPath = ruleAssemblyPath;
        RuleTypes = ruleTypes;
      }

      [NotNull]
      public string RuleAssemblyPath { get; }

      [NotNull]
      public IReadOnlyList&lt;Type&gt; RuleTypes { get; }
    }
  }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,11,20,69,1],[22,7,22,28,1],[27,7,27,36,1],[27,36,27,78,1],[27,78,27,100,1],[27,100,27,101,1],[27,36,27,101,1],[27,101,27,103,1],[27,7,27,103,1],[32,7,32,63,1],[33,7,33,54,1],[33,54,33,121,1],[33,121,34,21,1],[33,7,34,21,1],[36,7,36,32,1],[37,9,37,125,1],[39,7,39,73,1],[46,9,46,49,1],[48,7,48,36,1],[50,9,50,99,1],[52,7,52,27,1],[54,9,54,115,1],[56,5,56,6,1],[60,7,60,146,1],[62,16,62,28,1],[62,29,62,31,1],[62,32,62,51,1],[66,11,66,53,1],[67,9,67,10,1],[68,9,68,52,1],[70,11,70,118,1],[71,11,71,86,1],[72,9,72,10,1],[75,7,75,52,1],[77,9,77,75,1],[78,9,78,49,1],[81,7,83,43,1],[83,43,85,49,1],[85,49,85,154,1],[85,154,85,155,1],[83,43,85,155,1],[85,155,85,157,1],[81,7,85,157,1],[87,7,87,43,1],[88,7,88,45,1],[100,7,100,86,1],[102,9,102,45,1],[103,9,103,31,1]]);
    </script>
  </body>
</html>